// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: tasks.sql

package dbgen

import (
	"context"
	"time"
)

const createTask = `-- name: CreateTask :one
INSERT INTO task (id, type, payload, status, status_updated_at, attempts, created_by, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, type, payload, status, status_updated_at, attempts, created_by, created_at
`

type CreateTaskParams struct {
	ID              string
	Type            string
	Payload         *string
	Status          string
	StatusUpdatedAt time.Time
	Attempts        int32
	CreatedBy       string
	CreatedAt       time.Time
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.ID,
		arg.Type,
		arg.Payload,
		arg.Status,
		arg.StatusUpdatedAt,
		arg.Attempts,
		arg.CreatedBy,
		arg.CreatedAt,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.StatusUpdatedAt,
		&i.Attempts,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getTask = `-- name: GetTask :one
SELECT id, type, payload, status, status_updated_at, attempts, created_by, created_at FROM task WHERE id = $1
`

func (q *Queries) GetTask(ctx context.Context, id string) (Task, error) {
	row := q.db.QueryRow(ctx, getTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.StatusUpdatedAt,
		&i.Attempts,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const pickTask = `-- name: PickTask :one
WITH oldest_created AS (
    SELECT id
    FROM task
    WHERE task.status IN ('created', 'failed') AND task.attempts < $1
    ORDER BY created_at ASC
    LIMIT 1 FOR UPDATE SKIP LOCKED
)
UPDATE task SET
    status = 'processing',
    status_updated_at = NOW(),
    attempts = attempts + 1
WHERE id = (SELECT id FROM oldest_created)
RETURNING id, type, payload, status, status_updated_at, attempts, created_by, created_at
`

func (q *Queries) PickTask(ctx context.Context, attempts int32) (Task, error) {
	row := q.db.QueryRow(ctx, pickTask, attempts)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.StatusUpdatedAt,
		&i.Attempts,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
UPDATE task SET status = $2, status_updated_at = NOW() WHERE id = $1
`

type UpdateTaskStatusParams struct {
	ID     string
	Status string
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) error {
	_, err := q.db.Exec(ctx, updateTaskStatus, arg.ID, arg.Status)
	return err
}
